---
title: "Yamanaka_RNASeq_Analysis_3d_2wks_separately"
output: html_document
date: "2025-12-22"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#install.packages("renv")
##renv::init()        # Initialize project environment
##renv::snapshot()    # Save package versions to renv.lock
##renv::restore()     # Recreate exact environment elsewhere

## Renew GitHub Token
# You must have a GitHub Personal Access Token (PAT) stored securely.
# If not already configured, run this once manually before using the script:
#gitcreds_set()

# # Retrieve token from the gitcreds store
# token <- gitcreds::gitcreds_get()$password


#if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")

# Set Bioc version to latest (3.22)
#BiocManager::install(version = "3.22")

#bioc_pkgs <- c(
#  "KEGGREST", "Biobase", "AnnotationDbi", "S4Vectors", "Biostrings",
#  "Seqinfo", "BiocVersion", "org.Mm.eg.db", "XVector", "IRanges", "BiocGenerics"
#)

#BiocManager::install(bioc_pkgs, update = TRUE, ask = FALSE)
#renv::install(c("here", "fs", "DT", "dplyr", "stringr", "tibble", "qs"))
#renv::install("enrichplot")
#renv::install("tibble")
#renv::install("ggrepel")
#renv::settings$bioconductor.version("3.22")
#renv::snapshot()   # records exact versions in renv.lock

library(usethis)
library(renv)
library(gitcreds)
library(dplyr)
library(stringr)
library(DESeq2)
library(here)
library(fs)
library(ggplot2)
library(pheatmap)
library(reshape2)
library(AnnotationDbi)
library(org.Mm.eg.db)
library(clusterProfiler)
library(qs)
library(enrichplot)
library(tibble)
library(ggrepel)

#Use external function script
source("scripts/plotPCA2.R")
source("scripts/runGSEA.R")

```

Documentation of used code.
This is the script in which I analyze the timepoints of 3d and 2 weeks after injury only, in a distinct DESeq2 analysis. Most of the script will look the same as the Yamanaka_RNASeq_Analasys.Rmd file, I am just changing bits of the code, but will leave also the assigned names of the different analysis etc. mostly the same. 

## Load gene counts table

I am setting the directory and giving the name for the gene count table to be loaded into the R environment.

```{r read file}
genecount_file <- "gene_counts_YFproject.csv"

file_path <- here("data", "processed_data", "counts_data", genecount_file)

M <- read.csv(file_path,
              header = TRUE,
              quote = "",
              check.names = FALSE,
              stringsAsFactors = FALSE,
              row.names = 1)   # <- FIRST COLUMN as row names

```

### Adjust column and row names

```{r column names}

# --- Clean column names (sample names) ---
colnames(M) <- colnames(M) %>%
  str_remove_all('"') %>%        # remove any quotes
  str_remove("^K_") %>%          # remove prefix "K_"
  str_remove("_sorted\\.bam$")   # remove suffix "_sorted.bam"

# --- Clean row names (Entrez IDs) ---
rownames(M) <- rownames(M) %>%
  str_remove_all('"')             # remove any quotes

# display the first 6 rows:
dt <- DT::datatable(M |> head())
dt
```

I will perform the DESeq2 analysis still using the EntrezIDs because if I transform them into gene names first, I will lose information, since not all EntrezIDs have different gene names (there are duplicates, or NAs).

## Optimize data before analysis
I will remove genes with total counts below 10, as well as round values.

```{r Table adjustments before analysis}
#discard genes with a total count < 10
min_count <- 10
M <- M[rowSums(M) >= min_count,] #this steps reduces the amount of detected genes from 45569 to 23150

```



## Set up the Input for DESeq2 - now only containing the mice of the 3d timepoint.

In order to run the DESeq2 analysis, we need a meta table containing all information of different groups and treatments.


```{r ColData}
# Sample names must match the count matrix column names
sample_names <- c("Y340", "Y341", "Y342", "Y343", "Y344", "Y345", "Y346", "Y347", "Y348", "Y349", 
                  "Y350", "Y351", "Y352", "Y353", "Y354", "Y355", "Y356")

# Create metadata
colData <- data.frame(
  row.names = sample_names,
  time = c("3d", "3d", "3d", "3d", "3d", "3d", "3d", "3d", "2wks", "2wks", 
           "2wks", "2wks", "2wks", "2wks", "2wks", "2wks", "2wks"),
  genotype = c("Ctrl", "CrePos", "CrePos", "Ctrl", "Ctrl", "CrePos", "CrePos", "Ctrl", "CrePos", "CrePos", 
               "Ctrl", "Ctrl", "Ctrl", "CrePos", "CrePos", "CrePos", "Ctrl"),
  age_dis = c(129, 129, 107, 107, 83, 83, 55, 55, 121, 121, 
              121, 121, 97, 97, 97, 69, 69), #age at dissection
  age_ind = c(126, 126, 104, 104, 80, 80, 52, 52, 104, 104,
              104, 104, 80, 80, 80, 52, 52) # age at doxycycline induction
)

# We will only use either age at dissection or age at doxycycline induction.

# Make sure group/treatment are factors
colData$time <- factor(colData$time)
colData$genotype <- factor(colData$genotype)

#Set reference levels
colData$time <- relevel(colData$time, ref = "3d")
colData$genotype <- relevel(colData$genotype, ref = "Ctrl")

is.numeric(colData$age_dis)  # should be TRUE
is.numeric(colData$age_ind)  # should be TRUE

```

## Correcting the Input for DESeq2 - now only containing the mice of the 3d /2weeks timepoint.

```{r Subsets for both timepoints}

# ============================================
# Subset for 3d timepoint
# ============================================

# identify 3d samples 
samples_3d <- rownames(colData)[colData$time == "3d"]

# subset Count-Matrix for 3d samples
M_3d <- M[, samples_3d]

# subset metadata and drop time-level for 3d samples
colData_3d <- colData[samples_3d, ]
colData_3d$time <- droplevels(colData_3d$time)

# check
dim(M_3d)  # should have 8 samples 
colData_3d


# ============================================
# Subset for 2wks timepoint
# ============================================

# identify 2wks samples
samples_2wks <- rownames(colData)[colData$time == "2wks"]

# subset Count-Matrix for 2wks samples
M_2wks <- M[, samples_2wks]

# subset metadata and drop time-level for 2wks samples
colData_2wks <- colData[samples_2wks, ]
colData_2wks$time <- droplevels(colData_2wks$time)

# check
dim(M_2wks)  # should have 9 samples 
colData_2wks

```


```{r DESeq2 analysis for both timepoints}
## Running DESeq2 Analysis for each timepoint
# ============================================

# 3d Analysis
dds_3d <- DESeqDataSetFromMatrix(
  countData = M_3d,
  colData = colData_3d,
  design = ~ age_dis + genotype  # or ~ genotype, if correction for age not wanted
)
dds_3d <- DESeq(dds_3d)
res_3d <- results(dds_3d, contrast = c("genotype", "CrePos", "Ctrl")) # sets Ctrl as reference

qsave(dds_3d, "results/differential_expression/dds_3d.qs")


# 2wks Analyse
dds_2wks <- DESeqDataSetFromMatrix(
  countData = M_2wks,
  colData = colData_2wks,
  design = ~ age_dis + genotype 
)
dds_2wks <- DESeq(dds_2wks)
res_2wks <- results(dds_2wks, contrast = c("genotype", "CrePos", "Ctrl"))

qsave(dds_2wks, "results/differential_expression/dds_2wks.qs")

```


### Checking results

```{r Data tables for both timepoints}

#put results in a nice table
dt <- DT::datatable(
  res_3d |> as.data.frame() |>
    dplyr::filter(!is.na(padj), padj <= 0.05) |>
    dplyr::arrange(padj),

  options=list(scrollY="500px")
)

# convert numeric columns to scientific notation
dt <- dt |>
  DT::formatSignif(
    sapply(dt$x$data, is.numeric),
    digits=2
  )
dt

#put results in a nice table
dt <- DT::datatable(
  res_2wks |> as.data.frame() |>
    dplyr::filter(!is.na(padj), padj <= 0.05) |>
    dplyr::arrange(padj),

  options=list(scrollY="500px")
)

# convert numeric columns to scientific notation
dt <- dt |>
  DT::formatSignif(
    sapply(dt$x$data, is.numeric),
    digits=2
  )
dt



```

Now run quality control (QC) on this analysis, to check for batch effects, outliers, sample swaps with a first PCA.

```{r PCA plots, warning = FALSE}

#### Preparation for PCA ####
# The "blind" parameter tells the function NOT to use the input object's model formula for identifying "valid" (expected) variation. 
# We do this here because we have not yet found an optimal formula.
# For QC and testing for batch effects we will use the "blind" parameter.

vsd_blind_3d <- vst(dds_3d, blind=TRUE)

saveRDS(vsd_blind_3d,file="results/qc/vsd_blind_3d.rds")

plotPCA2(vsd_blind_3d,
         intgroup = "genotype",
         ntop=500,
         PCs=c(x=1,y=2))

# plot PCA, coloring different genotypes and times
colData(vsd_blind_3d)$genotype_age <- factor(
  paste(colData(vsd_blind_3d)$genotype, colData(vsd_blind_3d)$age_dis, sep="_")
)

plotPCA2(vsd_blind_3d,
         intgroup = "age_dis", #only coloring age
         ntop = 500,
         PCs = c(x=1, y=2),
         colour = group,
         shape = genotype)  # shape shows genotype


### for 2wks

vsd_blind_2wks <- vst(dds_2wks, blind=TRUE)

saveRDS(vsd_blind_2wks,file="results/qc/vsd_blind_2wks.rds")

plotPCA2(vsd_blind_2wks,
         intgroup = "genotype",
         ntop=500,
         PCs=c(x=1,y=2))

# plot PCA, coloring different genotypes and times
colData(vsd_blind_2wks)$genotype_time <- factor(
  paste(colData(vsd_blind_2wks)$genotype, colData(vsd_blind_2wks)$time, sep="_")
)

plotPCA2(vsd_blind_2wks,
         intgroup = "age_dis",
         ntop = 500,
         PCs = c(x=1, y=2),
         colour = group,
         shape = genotype)  


```

Now creating a heatmap of the 500 most highly expressed genes.

### Heatmap for 3d analysis

```{r Heatmap of DESeq2 Analysis 1 - 3 day analysis}
# Select top 500 most expressed genes (after DESeq2 normalization)
selected <-
  order(rowMeans(counts(dds_3d,
                        normalized=TRUE)
  ),
  decreasing=TRUE)[1:500]

# Create a metadata dataframe for annotation
df <- as.data.frame(colData(dds_3d))[, c("age_dis", "genotype")]

# Optional: make factors for annotation
df$genotype <- factor(df$genotype)
#df$time <- factor(df$time)

pheatmap(assay(vsd_blind_3d)[selected,],
         cluster_rows=FALSE,
         show_rownames=FALSE,
         show_colnames=FALSE,
         cluster_cols=TRUE,
         annotation_col=df)


```

### Heatmap for 2 weeks analysis

```{r Heatmap of DESeq2 Analysis 1 - 2 weeks analysis}
# Select top 500 most expressed genes (after DESeq2 normalization)
selected <-
  order(rowMeans(counts(dds_2wks,
                        normalized=TRUE)
  ),
  decreasing=TRUE)[1:500]

# Create a metadata dataframe for annotation
df <- as.data.frame(colData(dds_2wks))[, c("age_dis", "genotype")]

# Optional: make factors for annotation
df$genotype <- factor(df$genotype)

pheatmap(assay(vsd_blind_2wks)[selected,],
         cluster_rows=FALSE,
         show_rownames=FALSE,
         show_colnames=FALSE,
         cluster_cols=TRUE,
         annotation_col=df)


```



In order to check if the normalization "worked", I will plot a boxplot of the per-sample count distributions. All medians should be aligned.


```{r Boxplot of Per-Sample Count Distributions}
# melt counts
df <- rbind(
  reshape2::melt(log10(counts(dds_3d, normalized=FALSE) + 1)) %>% mutate(mode="raw"),
  reshape2::melt(log10(counts(dds_3d, normalized=TRUE) + 1)) %>% mutate(mode="normalized")
) %>%
  dplyr::rename(gene=Var1, sample=Var2, count=value) %>% # rename to make variable names more meaningful
  # merge metadata so you can color/fill by it
  left_join(
    as.data.frame(colData(dds_3d)) %>% mutate(sample = rownames(.)),
    by = "sample"
  ) %>%
  mutate(mode = factor(mode, levels=c("raw","normalized")))

# boxplot colored by genotype
ggplot(df, aes(x = sample, y = count, fill = genotype)) +
  geom_boxplot(outlier.size = 0.5) +
  facet_wrap(~mode, scales = "free_y", ncol = 2) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8)) +
  labs(x = "Sample", y = "log10(count + 1)", fill = "Genotype")


```


```{r Means and Medians}

cnt <- counts(dds_3d,normalized=TRUE)
medians_log10 <- log10(colMedians(cnt |> as.matrix())+1)

tapply(medians_log10, # what to group
           names(medians_log10),
       mean  # function to apply to grouped values
) |>
  sort(decreasing=TRUE) # sort the result

colMeans <- apply(cnt, 2, mean)
colMeans
```

There is not a sample that differs broadly from the others, nor is there a broad batch effect visible. Medians and means are very much aligned. 


# Analysis Part 2 

Now I want to look into more detail into differential expression for each timepoint separately.
The model I already earlier looks at  

- effect of interest: genotype

- covariate to control for: age_dis (numeric, Age of dissection)

Biological question is: “What genes differ by genotype directly after Yamanaka factor induction (3d, short-term) or after 2 weeks (long-term), accounting for age at dissection?”

Using these analyses, it is then possible to identify the genes that are up- / downregulated ONLY short or long-term, the genes that are consistently up- / downregulated after induction at both timepoints, and the genes that have opposing (compensating?) effects (first down-/upregulted, then the opposite at the later timepoints). And of course the genes that are not affected by the induction with Yamanaka factors.


I will now transform Entrez IDs that were in the BAM files to gene names using org.Mm.eg.db and add to the results  table.

### 3d analysis - adding gene names to table


```{r gene names}
# Convert Entrez IDs of my res_results to gene symbols
entrez_ids_3d <- rownames(res_3d)
gene_symbols <- mapIds(org.Mm.eg.db,
                       keys = entrez_ids_3d,
                       column = "SYMBOL",
                       keytype = "ENTREZID",
                       multiVals = "first")  # take first if multiple matches

#Add gene symbols to the results table
res_3d_df <- as.data.frame(res_3d) |>
  mutate(
    entrez_id   = rownames(res_3d),
    gene_symbol = gene_symbols[entrez_id]
  )

# Convert Entrez IDs of my res_results to gene names
gene_names <- mapIds(
  org.Mm.eg.db,
  keys      = entrez_ids_3d,
  column    = "GENENAME",
  keytype   = "ENTREZID",
  multiVals = "first"
)

#Add gene names to the results table
res_3d_df <- res_3d_df |>
  mutate(gene_name = gene_names[entrez_id])

#Check how many Entrez IDs do not correlate to a gene symbol
table(is.na(res_3d_df$gene_symbol))
# actually 68 genes are not connected to a gene symbol

qsave(res_3d_df, "results/differential_expression/res_3d_df.qs")
```

### 2 weeks analysis - adding gene names to table


```{r - add gene names to both tables}
#2 weeks table  
  
# Convert Entrez IDs of my res_results to gene symbols
entrez_ids_2wks <- rownames(res_2wks)
gene_symbols <- mapIds(org.Mm.eg.db,
                       keys = entrez_ids_2wks,
                       column = "SYMBOL",
                       keytype = "ENTREZID",
                       multiVals = "first")  # take first if multiple matches

#Add gene symbols to the results table
res_2wks_df <- as.data.frame(res_2wks) |>
  mutate(
    entrez_id   = rownames(res_2wks),
    gene_symbol = gene_symbols[entrez_id]
  )

# Convert Entrez IDs of my res_results to gene names
gene_names <- mapIds(
  org.Mm.eg.db,
  keys      = entrez_ids_2wks,
  column    = "GENENAME",
  keytype   = "ENTREZID",
  multiVals = "first"
)

#Add gene names to the results table
res_2wks_df <- res_2wks_df |>
  mutate(gene_name = gene_names[entrez_id])

#Check how many Entrez IDs do not correlate to a gene symbol
table(is.na(res_2wks_df$gene_symbol))
# actually 68 genes are not connected to a gene symbol

qsave(res_2wks_df, "results/differential_expression/res_2wks_df.qs")
```


Now let's look at the gene tables.

### Gene table for 3d analysis

```{r - 3d analysis gene table}
#make a table
dt <- DT::datatable(
  res_3d_df |> as.data.frame() |>
    dplyr::filter(!is.na(padj), padj <= 0.05) |>
    dplyr::arrange(padj),

  options=list(scrollY="500px",
               lengthMenu = list(c(10, -1),
                                 c('10','All'))
  )
)

# convert numeric columns to scientific notation
dt <- dt |>
  DT::formatSignif(sapply(dt$x$data, is.numeric),
                   digits=2
  )
dt


```

### Gene table for 2wks analysis

```{r - 2wks analysis gene table}
#make a table
dt <- DT::datatable(
  res_2wks_df |> as.data.frame() |>
    dplyr::filter(!is.na(padj), padj <= 0.05) |>
    dplyr::arrange(padj),

  options=list(scrollY="500px",
               lengthMenu = list(c(10, -1),
                                 c('10','All'))
  )
)

# convert numeric columns to scientific notation
dt <- dt |>
  DT::formatSignif(sapply(dt$x$data, is.numeric),
                   digits=2
  )
dt


```

Looking now at the PCA with the new analysis and not blind VST.


```{r Multivariate PCA plots}
# 3d analysis
vsd_unblind_3d <- vst(dds_3d, blind=FALSE)

saveRDS(vsd_unblind_3d,file="results/qc/vsd_unblind_3d.rds")

plotPCA2(vsd_unblind_3d,
         intgroup = "genotype",
         ntop=500,
         PCs=c(x=1,y=2))

# plot PCA, coloring different genotypes and times
#colData(vsd_unblind_3d)$genotype_time <- factor(
#  paste(colData(vsd_unblind)$genotype, colData(vsd_blind)$time, sep="_")
#)

plotPCA2(vsd_unblind_3d,
         intgroup = "age_dis",
         ntop = 500,
         PCs = c(x=1, y=2),
         colour = group,
         shape = genotype
         )  # <- this maps colors)


#2wks analysis
vsd_unblind_2wks <- vst(dds_2wks, blind=FALSE)

saveRDS(vsd_unblind_2wks,file="results/qc/vsd_unblind_2wks.rds")

plotPCA2(vsd_unblind_2wks,
         intgroup = "genotype",
         ntop=500,
         PCs=c(x=1,y=2))

# plot PCA, coloring different genotypes and times
#colData(vsd_unblind_3d)$genotype_time <- factor(
#  paste(colData(vsd_unblind)$genotype, colData(vsd_blind)$time, sep="_")
#)

plotPCA2(vsd_unblind_2wks,
         intgroup = "age_dis",
         ntop = 500,
         PCs = c(x=1, y=2),
         colour = group,
         shape = genotype
         )  # <- this maps colors)
```

Both look very similar to the "blind" versions of the VST. 

## Overrepresentation Analysis

Now coming to the interpretable analyses, I will start with ORA. 

### 3d analyses - CAVE: variables have same names as for 2wks analyses! First finish one, then move on to the other

```{r ORA 3d analyses}
#if starting from here, load dds_3d
res_3d_df <- qread("results/differential_expression/res_3d_df.qs")

#set "Universe" - defined as all genes that are actually expressed
uni_genes <- res_3d_df |>
  dplyr::filter(!is.na(padj)) |>
  dplyr::pull(gene_symbol) |>
  unique()

#upregulated genes
de_genes_up <- res_3d_df |>
  dplyr::filter(!is.na(padj), padj <= 0.05, log2FoldChange > 0) |>
  dplyr::pull(gene_symbol) |>
  unique()

#downregulated genes
de_genes_dn <- res_3d_df |>
  dplyr::filter(!is.na(padj), padj <= 0.05, log2FoldChange < 0) |>
  dplyr::pull(gene_symbol) |>
  unique()

ego_result_up <- enrichGO(gene = de_genes_up,
                          universe = uni_genes,
                          OrgDb = org.Mm.eg.db,
                          keyType = "SYMBOL",
                          ont = "BP",
                          pAdjustMethod = "BH",
                          pvalueCutoff = 0.05,
                          qvalueCutoff = 0.2,
                          readable = TRUE)


DT::datatable(head(ego_result_up)) # shows all genes that are now enriched for the pathways and how many there are

ego_result_dn <- enrichGO(
  gene = de_genes_dn,
  universe = uni_genes,
  OrgDb = org.Mm.eg.db,
  keyType = "SYMBOL",
  ont = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.05,
  qvalueCutoff = 0.2,
  readable = TRUE
)

DT::datatable(head(ego_result_dn))

```

#### Using log2FC threshold of 1 for short-term effects 

To detect stronger effects, we can also set the log2FC threshold to 1, so that only expression changes that are double (or half) are being used for clearer / more specific effects


```{r strong GO effects for 3 day analysis}
#upregulated genes
de_genes_up_strong <- res_2wks_df |>
  dplyr::filter(!is.na(padj), padj <= 0.05, log2FoldChange > 1) |>
  dplyr::pull(gene_symbol) |>
  unique()

#downregulated genes
de_genes_dn_strong <- res_2wks_df |>
  dplyr::filter(!is.na(padj), padj <= 0.05, log2FoldChange < -1) |>
  dplyr::pull(gene_symbol) |>
  unique()

ego_result_up_strong <- enrichGO(gene = de_genes_up_strong,
                          universe = uni_genes,
                          OrgDb = org.Mm.eg.db,
                          keyType = "SYMBOL",
                          ont = "BP",
                          pAdjustMethod = "BH",
                          pvalueCutoff = 0.05,
                          qvalueCutoff = 0.2,
                          readable = TRUE)


DT::datatable(head(ego_result_up_strong)) # shows all genes that are now enriched for the pathways and how many there are

ego_result_dn_strong <- enrichGO(
  gene = de_genes_dn_strong,
  universe = uni_genes,
  OrgDb = org.Mm.eg.db,
  keyType = "SYMBOL",
  ont = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.05,
  qvalueCutoff = 0.2,
  readable = TRUE
)

DT::datatable(head(ego_result_dn_strong))

```




#### Visualization of ORA for 3 day analysis

There are many different plot types that we can use for visualization. 

```{r ORA Visualization 3 day analysis}

dotplot(ego_result_up, showCategory=10) +
  ggtitle("GO Enrichment Analysis - Upregulated Genes : Dotplot")
dotplot(ego_result_dn, showCategory=10) +
  ggtitle("GO Enrichment Analysis - Downregulated Genes : Dotplot")

barplot(ego_result_up, showCategory=10) +
  ggtitle("GO Enrichment Analysis - Upregulated Genes : Barplot")
barplot(ego_result_dn, showCategory=10) +
  ggtitle("GO Enrichment Analysis - Downregulated Genes : Barplot")

#Category gene network plots
cnetplot(ego_result_up, categorySize="pvalue", foldChange=NULL) +
  ggtitle("GO Enrichment Analysis - Upregulated Genes : Cnetplot")
cnetplot(ego_result_dn, categorySize="pvalue", foldChange=NULL) +
  ggtitle("GO Enrichment Analysis - Downregulated Genes : Cnetplot")

#Emapplots
ego_result_up_enrich <- enrichplot::pairwise_termsim(ego_result_up)
ego_result_dn_enrich <- enrichplot::pairwise_termsim(ego_result_dn)
emapplot(ego_result_up_enrich, showCategory=10) +
  ggtitle("GO Enrichment Analysis - Upregulated Genes : Emapplot")
emapplot(ego_result_dn_enrich, showCategory=10) +
  ggtitle("GO Enrichment Analysis - Downregulated Genes : Emapplot")


```

### visualizing only STRONG effects for 3 day analysis

```{r}
dotplot(ego_result_up_strong, showCategory=20) +
  ggtitle("GO Enrichment Analysis - Strongly Upregulated Genes : Dotplot")
dotplot(ego_result_dn_strong, showCategory=20) +
  ggtitle("GO Enrichment Analysis - Strongly Downregulated Genes : Dotplot")
```



### 2 weeks analyses - CAVE: variables have same names as for 3d analyses! First finish one, then move on to the other

Now doing exactly the same for the 2 weeks analysis


```{r ORA 2wks analyses}
#if starting from here, load dds_2wks
res_2wks_df <- qread("results/differential_expression/res_2wks_df.qs")

#set "Universe" - defined as all genes that are actually expressed
uni_genes <- res_2wks_df |>
  dplyr::filter(!is.na(padj)) |>
  dplyr::pull(gene_symbol) |>
  unique()

#upregulated genes
de_genes_up <- res_2wks_df |>
  dplyr::filter(!is.na(padj), padj <= 0.05, log2FoldChange > 0) |>
  dplyr::pull(gene_symbol) |>
  unique()

#downregulated genes
de_genes_dn <- res_2wks_df |>
  dplyr::filter(!is.na(padj), padj <= 0.05, log2FoldChange < 0) |>
  dplyr::pull(gene_symbol) |>
  unique()

ego_result_up <- enrichGO(gene = de_genes_up,
                          universe = uni_genes,
                          OrgDb = org.Mm.eg.db,
                          keyType = "SYMBOL",
                          ont = "BP",
                          pAdjustMethod = "BH",
                          pvalueCutoff = 0.05,
                          qvalueCutoff = 0.2,
                          readable = TRUE)


DT::datatable(head(ego_result_up)) # shows all genes that are now enriched for the pathways and how many there are

ego_result_dn <- enrichGO(
  gene = de_genes_dn,
  universe = uni_genes,
  OrgDb = org.Mm.eg.db,
  keyType = "SYMBOL",
  ont = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.05,
  qvalueCutoff = 0.2,
  readable = TRUE
)

DT::datatable(head(ego_result_dn))
```




#### Using log2FC threshold of 1 / -1 for long-term effects for 2 week analysis

To detect stronger effects, we can also set the log2FC threshold to 1, so that only expression changes that are double (or half) are being used for clearer / more specific effects


```{r strong GO effects for 2 weeks analysis}
#upregulated genes
de_genes_up_strong <- res_2wks_df |>
  dplyr::filter(!is.na(padj), padj <= 0.05, log2FoldChange > 1) |>
  dplyr::pull(gene_symbol) |>
  unique()

#downregulated genes
de_genes_dn_strong <- res_2wks_df |>
  dplyr::filter(!is.na(padj), padj <= 0.05, log2FoldChange < -1) |>
  dplyr::pull(gene_symbol) |>
  unique()

ego_result_up_strong <- enrichGO(gene = de_genes_up_strong,
                          universe = uni_genes,
                          OrgDb = org.Mm.eg.db,
                          keyType = "SYMBOL",
                          ont = "BP",
                          pAdjustMethod = "BH",
                          pvalueCutoff = 0.05,
                          qvalueCutoff = 0.2,
                          readable = TRUE)


DT::datatable(head(ego_result_up_strong)) # shows all genes that are now enriched for the pathways and how many there are

ego_result_dn_strong <- enrichGO(
  gene = de_genes_dn_strong,
  universe = uni_genes,
  OrgDb = org.Mm.eg.db,
  keyType = "SYMBOL",
  ont = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.05,
  qvalueCutoff = 0.2,
  readable = TRUE
)

DT::datatable(head(ego_result_dn_strong))

```



### Visualization 2 weeks results

Now again, showing all different kinds of plots

```{r ORA Visualization 2 weeks}

dotplot(ego_result_up, showCategory=10) +
  ggtitle("GO Enrichment Analysis - Upregulated Genes : Dotplot")
dotplot(ego_result_dn, showCategory=10) +
  ggtitle("GO Enrichment Analysis - Downregulated Genes : Dotplot")

barplot(ego_result_up, showCategory=10) +
  ggtitle("GO Enrichment Analysis - Upregulated Genes : Barplot")
barplot(ego_result_dn, showCategory=10) +
  ggtitle("GO Enrichment Analysis - Downregulated Genes : Barplot")

#Category gene network plots
cnetplot(ego_result_up, categorySize="pvalue", foldChange=NULL) +
  ggtitle("GO Enrichment Analysis - Upregulated Genes : Cnetplot")
cnetplot(ego_result_dn, categorySize="pvalue", foldChange=NULL) +
  ggtitle("GO Enrichment Analysis - Downregulated Genes : Cnetplot")

#Emapplots
ego_result_up_enrich <- enrichplot::pairwise_termsim(ego_result_up)
ego_result_dn_enrich <- enrichplot::pairwise_termsim(ego_result_dn)
emapplot(ego_result_up_enrich, showCategory=10) +
  ggtitle("GO Enrichment Analysis - Upregulated Genes : Emapplot")
emapplot(ego_result_dn_enrich, showCategory=10) +
  ggtitle("GO Enrichment Analysis - Downregulated Genes : Emapplot")


```

### visualizing only STRONG effects for 2 week analysis

```{r}
dotplot(ego_result_up_strong, showCategory=12) +
  ggtitle("GO Enrichment Analysis - Strongly Upregulated Genes : Dotplot")
dotplot(ego_result_dn_strong, showCategory=12) +
  ggtitle("GO Enrichment Analysis - Strongly Downregulated Genes : Dotplot")
```


## Gene Set Enrichment Analysis ##

GSEA gene lists are ranked, by a principally arbitrary rank metric. The rank will be "walked down" and overlaps with the gene set will increase the score, while the score will decrease again for non-overlapping genes, giving a "curve", thus also giving a "spacial" information, in which rank area the overlaps occur.

GSEA uses GO term descriptions and Normalized Enrichment Score (NES): 
A positive NES means → gene set is enriched at the top of the ranked list (upregulated).
A negative NES means → gene set is enriched at the bottom (downregulated).


### 3 days analysis for GSEA - CAVE: also here I am using same variables name for 2 different timepoints. First run one, then the other!


```{r GSEA 3 days}
##Create a ranked gene list for GSEA
#use the Wald statistic (res$stat):

df <- res_3d_df |>
  dplyr::filter(!is.na(padj)) |>
  dplyr::arrange(desc(stat)) |>
  dplyr::filter(!is.na(gene_symbol))

geneList <- df$stat
names(geneList) <- df$gene_symbol

#using the external script
gsea_results <- runGSEA(
  geneList = geneList,
  OrgDb = org.Mm.eg.db,
  keyType = "SYMBOL",   # or "ENSEMBL", depending on your data
  ontologies = c("BP","MF","CC")
)

#1. Check what’s in the list
names(gsea_results)

#2. Convert to a data frame
bp_df <- as.data.frame(gsea_results$BP)
mf_df <- as.data.frame(gsea_results$MF)
cc_df <- as.data.frame(gsea_results$CC)

#3. View top pathways
head(bp_df[order(bp_df$p.adjust), ])

#4. Extract only the significant pathways
sig_bp <- bp_df[bp_df$p.adjust <= 0.05, ]

#5. Access specific info
# The column with actual contributing genes is 'core_enrichment'
bp_df$core_enrichment[1]
# Split into vector
genes <- strsplit(bp_df$core_enrichment[1], "/")[[1]]

sig_bp[, c("Description", "NES", "p.adjust")] 

#6 Plot results
bp_df <- as.data.frame(gsea_results$BP)
bp_df <- bp_df[order(bp_df$p.adjust), ][1:15, ]  # top 10

ggplot(bp_df, aes(x = reorder(Description, NES), y = NES)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(y = "Normalized Enrichment Score (NES)", x = "GO Term")


# Dot plot
dotplot(gsea_results$BP, showCategory = 15)

# Enrichment plot for one gene set, at the moment for the most significant pathway (chromosome segregation)
gseaplot2(gsea_results$BP, geneSetID = sig_bp$ID[1])


```


### 2 weeks analysis for GSEA - CAVE: also here I am using same variables name for 2 different timepoints. First run one, then the other!


```{r GSEA 2 weeks}
##Create a ranked gene list for GSEA
#use the Wald statistic (res$stat):

df <- res_2wks_df |>
  dplyr::filter(!is.na(padj)) |>
  dplyr::arrange(desc(stat)) |>
  dplyr::filter(!is.na(gene_symbol))

geneList <- df$stat
names(geneList) <- df$gene_symbol

#using the external script
gsea_results <- runGSEA(
  geneList = geneList,
  OrgDb = org.Mm.eg.db,
  keyType = "SYMBOL",   # or "ENSEMBL", depending on your data
  ontologies = c("BP","MF","CC")
)

#1. Check what’s in the list
names(gsea_results)

#2. Convert to a data frame
bp_df <- as.data.frame(gsea_results$BP)
mf_df <- as.data.frame(gsea_results$MF)
cc_df <- as.data.frame(gsea_results$CC)

#3. View top pathways
head(bp_df[order(bp_df$p.adjust), ])

#4. Extract only the significant pathways
sig_bp <- bp_df[bp_df$p.adjust <= 0.05, ]

#5. Access specific info
# The column with actual contributing genes is 'core_enrichment'
bp_df$core_enrichment[1]
# Split into vector
genes <- strsplit(bp_df$core_enrichment[1], "/")[[1]]

sig_bp[, c("Description", "NES", "p.adjust")] 

#6 Plot results
bp_df <- as.data.frame(gsea_results$BP)
bp_df <- bp_df[order(bp_df$p.adjust), ][1:15, ]  # top 10

ggplot(bp_df, aes(x = reorder(Description, NES), y = NES)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(y = "Normalized Enrichment Score (NES)", x = "GO Term")


# Dot plot
dotplot(gsea_results$BP, showCategory = 15)

# Enrichment plot for one gene set, at the moment for the most significant pathway (chromosome segregation)
gseaplot2(gsea_results$BP, geneSetID = sig_bp$ID[1])


```


## Volcano Plot of significant differentially expressed genes

### Volcano Plot for 3 days analysis - short-term induction

```{r Volcano plot - 3 day analysis}

#add significance and threshold
lfc_thresh <- 1       # log2 fold change threshold
p_thresh   <- 0.05    # adjusted p-value threshold

#add significance column
res_3d_df <- res_3d_df |>
  mutate(
    significant = ifelse(!is.na(padj) & padj <= p_thresh & abs(log2FoldChange) >= lfc_thresh,
                         ifelse(log2FoldChange > 0, "Up", "Down"),
                         "NotSig")
  )

# Select top 20 most significant genes
top_genes <- res_3d_df |>
  filter(significant != "NotSig") |>
  arrange(padj) |>
  slice_head(n = 20)  # pick 20 smallest padj

# Create a clean dataset for plotting, filter out NA of padj in genes (reduces number of genes by 5386)
res_plot <- res_3d_df |>
  filter(!is.na(padj) & !is.na(log2FoldChange) & padj > 0)

ggplot(res_plot, aes(x = log2FoldChange, y = -log10(padj), color = significant)) +
  geom_point(alpha = 0.6, size = 1.5) +
  scale_color_manual(values = c("Up" = "red", "Down" = "blue", "NotSig" = "grey")) +
  geom_vline(xintercept = c(-lfc_thresh, lfc_thresh), linetype = "dashed") +
  geom_hline(yintercept = -log10(p_thresh), linetype = "dashed") +
  geom_text_repel(data = top_genes, aes(label = gene_symbol), size = 3) +
  theme_minimal() +
  labs(x = "log2 Fold Change", y = "-log10(p-value)", color = "Significance") +
  ggtitle("Volcano Plot with Top Genes for short-term effects (3 days)")

```

### Volcano Plot for 2 weeks analysis - long-term induction

```{r Volcano plot 2weeks analysis}

#add significance and threshold
lfc_thresh <- 1       # log2 fold change threshold
p_thresh   <- 0.05    # adjusted p-value threshold

#add significance column
res_2wks_df <- res_2wks_df |>
  mutate(
    significant = ifelse(!is.na(padj) & padj <= p_thresh & abs(log2FoldChange) >= lfc_thresh,
                         ifelse(log2FoldChange > 0, "Up", "Down"),
                         "NotSig")
  )

# Select top 20 most significant genes
top_genes <- res_2wks_df |>
  filter(significant != "NotSig") |>
  arrange(padj) |>
  slice_head(n = 20)  # pick 20 smallest padj

# Create a clean dataset for plotting, filter out NA of padj in genes (reduces number of genes by 5386)
res_plot <- res_2wks_df |>
  filter(!is.na(padj) & !is.na(log2FoldChange) & padj > 0)

ggplot(res_plot, aes(x = log2FoldChange, y = -log10(padj), color = significant)) +
  geom_point(alpha = 0.6, size = 1.5) +
  scale_color_manual(values = c("Up" = "red", "Down" = "blue", "NotSig" = "grey")) +
  geom_vline(xintercept = c(-lfc_thresh, lfc_thresh), linetype = "dashed") +
  geom_hline(yintercept = -log10(p_thresh), linetype = "dashed") +
  geom_text_repel(data = top_genes, aes(label = gene_symbol), size = 3) +
  theme_minimal() +
  labs(x = "log2 Fold Change", y = "-log10(p-value)", color = "Significance") +
  ggtitle("Volcano Plot with Top Genes for long-term effects (2 weeks after induction)")

```




